package leetcode._2022_08._004_删除子数组的最大得分;

import java.util.HashMap;
import java.util.Map;

public class _01_my {
    public static void main(String[] args) {
        Solution sol = new Solution();
        int val = sol.maximumUniqueSubarray(new int[]{544, 914, 868, 579, 654, 594, 577, 564, 905, 417, 436, 26, 901, 618, 620, 108, 971, 888, 961, 609, 617, 811, 814, 872, 503, 959, 621, 746, 644, 555, 80, 220, 192, 113, 219, 950, 889, 751, 571, 508, 751, 124, 167, 966, 35, 795, 336, 951, 284, 186, 432, 673, 629, 972, 952, 107, 134, 756, 301, 362, 940, 186, 386, 919, 789, 188, 662, 422, 917, 198, 827, 305, 657, 471, 478, 728, 881, 323, 67, 111, 299, 269, 165, 328, 890, 321, 541, 257, 637, 919, 876, 447, 576, 260, 203, 314, 252, 266, 419, 327, 429, 196, 743, 996, 280, 392, 749, 804, 313, 833, 148, 573, 37, 639, 345, 327, 662, 145, 643, 877, 148, 628, 807, 618, 881, 577, 222, 148, 842, 310, 34, 559, 828, 479, 631, 933, 386, 407, 568, 22, 973, 443, 239, 219, 560, 153, 463, 348, 272, 561, 925, 453, 849, 646, 497, 641, 43, 57, 394, 430, 308, 865, 749, 566, 689, 209, 941, 62, 383, 973, 252, 340, 302, 961, 703, 30, 545, 890, 96, 438, 601, 759, 649, 148, 449, 437, 117, 417, 792, 140, 118, 455, 893, 55, 155, 527, 685, 996, 155, 233, 824, 232, 339, 429, 83, 967, 905, 928, 943, 448, 723, 603, 404, 169, 132, 96, 302, 34, 682, 487, 356, 229, 580, 425, 481, 760, 755, 162, 623, 881, 687, 10, 512, 600, 981, 809, 495, 942, 615, 717, 266, 197, 216, 683, 338, 940, 902, 636, 848, 802, 186, 704, 363, 93, 516, 909, 347, 991, 817, 567, 500, 648, 672, 20, 384, 608, 726, 38, 474, 74, 358, 884, 385, 671, 65, 179, 172, 449, 973, 263, 397, 876, 266, 670, 86, 835, 386, 167, 824, 593, 698, 42, 241, 569, 487, 362, 867, 438, 368, 657, 616, 326, 215, 773, 946, 485, 570, 719, 375, 840, 255, 20, 500, 336, 440, 10, 596, 468, 140, 959, 844, 588, 72, 88, 446, 608, 238, 310, 927});
        System.out.println("-------------------华丽分割线----------------------");
        System.out.println(val);
    }

    static
        /**
         * 1695. 删除子数组的最大得分
         * 给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。删除子数组的 得分 就是子数组各元素之 和 。
         *
         * 返回 只删除一个 子数组可获得的 最大得分 。
         *
         * 如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],...,a[r] ，那么它就是 a 的一个子数组。
         *
         *
         *
         * 示例 1：
         *
         * 输入：nums = [4,2,4,5,6]
         * 输出：17
         * 解释：最优子数组是 [2,4,5,6]
         * 示例 2：
         *
         * 输入：nums = [5,2,1,2,5,2,1,2,5]
         * 输出：8
         * 解释：最优子数组是 [5,2,1] 或 [1,2,5]
         *
         *
         * 提示：
         *
         * 1 <= nums.length <= 105
         * 1 <= nums[i] <= 104
         */
    class Solution {
        public int maximumUniqueSubarray(int[] nums) {
            // 滑动窗口吧;
            // 记录下标 map
            Map<Integer, Integer> idxMap = new HashMap<>();
            // 开始记录idx
            idxMap.put(nums[0], 0);
            // 记录结果
            int res = nums[0];
            int tmp = nums[0];
            int len = nums.length;
            int left = 0;
            for (int right = 1; right < len; right++) {
                // 取出值
                int val = nums[right];
                tmp += val;
                Integer idx = idxMap.getOrDefault(val, -1);
                // 计算最大值
                if (idx < 0) {
                    idxMap.put(val, right);
                    res = Math.max(tmp, res);
                    continue;
                }
                // 存在值了
                while (left <= idx) {
                    // 移除
                    int removeVal = nums[left++];
                    // 漏了这一步
                    idxMap.remove(removeVal);
                    tmp -= removeVal;
                }
                idxMap.put(val, right);
            }
            return res;
        }
    }
}

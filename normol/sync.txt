synchronized
    JVM对象
        三块区域组成
            对象头
                Mark World
                    HashCode
                    GC年龄
                    锁相关信息等
                Klass Pointer
                    指向类元数据的指针
            实例数据
            对齐数据
        相关方法
            3个
                wait
                notify
                notifyAll
            获得锁并把相关信息存储在对象头
            方法为什么被设计在 Object
    对象头
        类型
            Hotspot
                两种类型
                    数组类型
                        arrayOopDesc
                    其他
                        instanceOopDesc
        Mark World
            存储运行时数据
                HashCode
                GC年龄
                锁相关信息等
            64位结构
                GC标记       0            11
            基本流程
                无锁
                    偏向锁
                        轻量级锁
                            重量级锁
        Klass Pointer
            类型指针
                指向类元数据的指针
    偏向锁
        加锁
            操作
                检查 mark word 的线程 id 。
                id = 空
                    设置 CAS 替换当前线程 id。如果替换成功则获取锁成功，如果失败则撤销偏向锁。
                id != 空
                    检查 线程 id为是否为本线程。如果是则获取锁成功，如果失败则撤销偏向锁。
            进入锁相关同步块
                只需比对一下 mark word 的线程 id 是否为本线程，如果是则获取锁成功。
            如果发生线程竞争发生 2、3 步失败
                需要撤销偏向锁
        撤销
            偏向锁的撤销动作必须等待全局安全点
            暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态
            撤销偏向锁恢复到无锁（标志位为 01）或轻量级锁（标志位为 00）的状态
        优点
            只有一个线程执行同步块时进一步提高性能
            适用场景
                一个线程反复获得同一锁的情况。
                偏向锁可以提高带有同步但无竞争的程序性能。
        缺点
            如果存在竞争会带来额外的锁撤销操作。
            HashCode问题
                HotSpot VM的锁实现机制
                    经计算过identity hash code，它就无法进入偏向锁状态
                    正处于偏向锁状态，并且需要计算其identity hash code的话
                        它的偏向锁会被撤销，并且锁会膨胀为轻量级锁或者重量锁
                    HashCode 其他记录位置
                        轻量级锁
                            线程栈帧的锁记录存储 Displaced Mark Word
                        重量级锁
                            ObjectMonitor类里有字段可以记录非加锁状态下的mark word，
                            其中可以存储identity hash code的值。
    轻量级锁
        场景
            多个线程竞争偏向锁导致偏向锁升级为轻量级锁
        加锁
            JVM 在当前线程的栈帧中创建 Lock Reocrd，
                并将对象头中的 Mark Word 
                复制到 Lock Reocrd 中。（Displaced Mark Word）
            线程尝试使用 CAS 将对象头中的 
                Mark Word 替换为指向 Lock Reocrd 的指针。
                成功
                    获得锁
                失败
                    先检查对象的 Mark Word 是否指向当前线程的栈帧
                    如果是则说明已经获取锁，
                    否则说明其它线程竞争锁则膨胀为重量级锁
        解锁
            使用 CAS 操作将 Mark Word 还原
                成功
                    释放成功
                失败
                    膨胀为重量级锁
        优点
            其性能提升的依据是对于绝大部分的锁在整个生命周期内都是不会存在竞争。
            在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。
        缺点
            在有多线程竞争的情况下轻量级锁增加了额外开销。
    自旋机制
        自旋
            是一种获取锁的机制
            不是一个锁状态
        JDK 1.6 之前
            默认情况下自旋次数是 10 次
            可以使用参数 -XX : PreBlockSpin 来更改
        JDK 6
            自适应自旋锁
            决定条件
                前一次在同一个锁上的自旋时间
                拥有者的状态
            如果对于某个锁很少自旋成功
                省略掉自旋过程以避免资源浪费
        优点
            竞争的线程不会阻塞挂起，提高了程序响应速度。
                避免重量级锁引起的性能消耗。
        缺点
            如果线程始终无法获取锁，自旋消耗 CPU 最终会膨胀为重量级锁。
    重量级锁
        介绍
            竞争
                没有竞争到锁的对象会 park 被挂起
                退出同步块时 unpark 唤醒后续线程。
            唤醒操作涉及到操作系统调度会有额外的开销。
        相关C++源码
            ObjectMonitor
                一个同步队列
                    组成
                        _cxq
                        _EntryList
                一个等待队列
                    组成
                        _WaitSet
                被notify或 notifyAll 唤醒时
                    根据 policy 策略选择加入的队列（policy 默认为 0）
                退出同步块时
                    根据 QMode 策略来唤醒下一个线程（QMode 默认为 0）
            与JDK AQS 相似
                只不过 AQS 中是一个同步队列多个等待队列。
        子主题
